# * *************************************************************
# *  
# *   Soft Active Mater on Surfaces (SAMoS)
# *   
# *   Author: Rastko Sknepnek
# *  
# *   Division of Physics
# *   School of Engineering, Physics and Mathematics
# *   University of Dundee
# *   
# *   (c) 2013, 2014
# * 
# *   School of Science and Engineering
# *   School of Life Sciences 
# *   University of Dundee
# * 
# *   (c) 2015
# * 
# *   Author: Silke Henkes
# * 
# *   Department of Physics 
# *   Institute for Complex Systems and Mathematical Biology
# *   University of Aberdeen  
# * 
# *   (c) 2014, 2015
# *  
# *   This program cannot be used, copied, or modified without
# *   explicit written permission of the authors.
# * 
# * ***************************************************************

#
#  Simulation of N=variable active particles interacting with the 
#  soft-core potential confined inside a circle of glued particles


# All runtime messages will be sent to file messages.msg
messages messages.msg

# Every simulation requires a box
# "periodic" means that periodic boundary are applied.
# box is cubic with size 100x100x10 (units of particle radius r = 1) and spans from -50 to 50 in 
# x and y directions and -5 to 5 in z direction
# This is essentially dummy; just make sure it's big enough
box periodic { lx = 50.0;  ly = 50.0;  lz = 50.0 }

# We read in particle positions from file circle.dat (generated by tools in utils directory)
input cornea.txt

# We set the neighbour list with cutoff distance 2.4 and padding distance of 0.5
# Longer for gaussian: reaches out till 3
nlist { rcut = 3.2; pad = 0.5 }

# The particles are divided into three groups: group 1 is moving, group 2 are the glued stem cells and group 3 is the glued boundary
group g1 { type = 0 }
group g2 { type = 1 }
group g3 { type = 2 }

# In following we define different data outputs

# Output particle velocities. Base name of the file is plane_test
# File extension will we '.vel'. Output will be generated every 10000 time steps
# staring from the step 0. Each snapshots will be stored in a separate file (keyword 'multi')
# with name plane_test_[time_step].vel (e.g., plane_test_0000010000.vel)
# and each file with contain a header with the description of its content
# dump circle_test { type=velocity; start=0; freq=10000; multi; header }

# Same as above, but the format will be XYZ and file extension '.xyz'
# dump circle_test { type=xyz; start=0; freq=10000; multi; header }

# In order to generate a trajectory, we output coordinates every 1000 time steps
# In this case all snapshots will be stored in one file 'plane_test.dcd'
# dump circle_test { type=dcd; start=0; freq=1000  }

# We also want to generate a director field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'plane_test_dir.xyzv'
# dump circle_test_dir { type=xyzv; start=0; freq=1000; scale = 0.25; header  }

# In addition we want to generate a velocity field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'plane_test_vel.xyzv'
# dump circle_test_vel { type=xyzv; start=0; freq=1000; scale = 0.1; velocity; header  }


# Finally, every 10000 steps we generate a separate file that contains 
# particle coordinates, velocities anf the director field (and the header)
dump cornea_test { type=full; start=0; freq=1000; multi; id; flag; tp; radius; coordinate; velocity; director; header  }


# We constrain all particles to move only on the xy plane with lx=100, ly = 100 (actually those are read from the box)
constraint sphere { r = 10 }


# All particles are interacting with the soft-core potential of strength 
# k = 1.0 (energy units)
# pair_potential soft { k = 1.0 }
 pair_potential morse { D = 0.2; a = 3.0; re = 2.0; use_particle_radii; phase_in=linear; min_val=0.0; max_val=1.0; steps=100 }
# pair_potential gaussian { A = 2.0; B = -1.0 }
# pair_potential morse { D = 1.5; a = 1.0; re = 1 }

# Alignment will be done using polar aligner 
# Coupling constant J = 1.0 (energy units)
pair_align polar { J = 1.0 }

# We would also like to monitor measure a few quantities
# Here we define a log that keeps track of step, velocity, soft core potenetial energy, and alignment 
# These quantities will be logged once every 1000 steps
# Note that step is always logged automatically
log plane_test.log { freq = 1000; velocity; soft_energy; polar_align }

# NVE integrator appears buggy if not soft
# In order to relax the system and remove large overlaps 
# we first run system using NVE integrator with maximum 
# displacement limit=0.001. Time step is dt = 0.001
integrator nve { dt=0.001; limit=0.0001; group = g1 }


# Run for 10,000 steps
run 100000

# Disable the first integrator
disable nve { group=g1 }

# Define the circle interaction parameters: Gaussian interaction between group 1 particles, strong repulsion
# between group 1 and 2 particles
# pair_param gaussian { type_1 = 1; type_2 = 1; A = 2.0; B = -1.0 }
# pair_param gaussian { type_1 = 1; type_2 = 2; A = 10.0; B = -1.0 }
# pair_param gaussian { type_1 = 2; type_2 = 2; A = 2.0; B = -1.0 }
# pair_param morse { type_1 = 1; type_2 = 1; D = 1.5; a = 1.0; re = 1 }
# pair_param morse { type_1 = 1; type_2 = 2; D = 3.0; a = 1.0; re = 1 }
# pair_param morse { type_1 = 2; type_2 = 2; D = 1.5; a = 1.0; re = 1 }
# pair_param soft { type_1 = 1; type_2 = 1; k=1.0 }
# pair_param soft { type_1 = 1; type_2 = 2; k=10.0 }
# pair_param soft { type_1 = 1; type_2 = 3; k=10.0 }
# pair_param soft { type_1 = 2; type_2 = 2; k=1.0 }
# pair_param soft { type_1 = 2; type_2 = 3; k=1.0 }
# pair_param soft { type_1 = 3; type_2 = 3; k=1.0 }

# Same for polar; have them interact, here to explore different boundary conditions
# align_param polar { type_1 = 1; type_2 = 1; J = 0.25 }
# align_param polar { type_1 = 1; type_2 = 2; J = 0.25 }
# align_param polar { type_1 = 2; type_2 = 2; J = 0.0 }
# align_param polar { type_1 = 1; type_2 = 3; J = 0.0 }
# align_param polar { type_1 = 2; type_2 = 3; J = 0.0 }
# align_param polar { type_1 = 3; type_2 = 3; J = 0.0 }

# Now we are at the point to execute actual simulations. 
# We switch the integrator to brownian.
# Integrate equations of motion using Brownian dynamics.
# seed is the initial seed for the random number generator
# dt is the integrator time step (in Lennard-Jones units) 
# nu sets the width of the distribution for random changes of velocity
# mu is particle mobility
# v0 is the intensity of the self-propelling velocity
integrator brownian { dt=0.001; seed = 1;  nu = 0.002; mu = 1.0;  v0 = 0.05; group = g1 }
# No integrator for the second one: they are glued

# Apply random population control only to group "g1 inside"
# Particle division rate is set to 1000
# Particle removal rate is set to 1000
# Division and removal are attempted only every 1000 steps
#population density { group = all; division_rate = 0.0003; split_distance=0.1,rho_max = 6.0,death_rate = 0.00006; freq = 1000  }
population density { group = g1; division_rate = 0.0; death_rate = 0.00025; rho_max = 6.0, freq = 1000; change_prob_1 = 0.0; change_prob_2 = 0.0 , old_group = g1; new_group = g1; old_type = 1; new_type = 1 }
#population density { group = g2; division_rate = 0.1; death_rate = 0.0; freq = 1000; change_prob_1 = 0.0; split_distance = 0.05; change_prob_2 = 1.0; old_group = g2; new_group = g1; old_type = 2; new_type = 1  }
population density { group = g2; division_rate = 0.025; death_rate = 0.0; freq = 1000; split_distance = 0.0;rho_max = 1000.0, change_prob_2 = 1.0; old_group = g2; new_group = g1; old_type = 2; new_type = 1 } 




# Finally, we run simulation for 100,000 time steps
run 100000



