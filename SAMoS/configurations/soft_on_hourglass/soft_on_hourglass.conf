# * *************************************************************
# *  
# *   Soft Active Mater on Surfaces (SAMoS)
# *   
# *   Author: Rastko Sknepnek
# *  
# *   Division of Physics
# *   School of Engineering, Physics and Mathematics
# *   University of Dundee
# *   
# *   (c) 2013, 2014
# * 
# *   School of Science and Engineering
# *   School of Life Sciences 
# *   University of Dundee
# * 
# *   (c) 2015
# * 
# *   Author: Silke Henkes
# * 
# *   Department of Physics 
# *   Institute for Complex Systems and Mathematical Biology
# *   University of Aberdeen  
# * 
# *   (c) 2014, 2015
# *  
# *   This program cannot be used, copied, or modified without
# *   explicit written permission of the authors.
# * 
# * ***************************************************************

# WARNING! Configuration files are case senisitve!

#
#  Simulation of N=600 active particles interacting with the 
#  soft-core potential confined on the surface of a hourglass
#  
#


# All runtime messages will be sent to file messages.msg
messages messages.msg

# Every simulation requires a box
# "fixed" means that no periodic boundary is applied (irrelevant here due to spherical geometry)
# box is cubic with size 30x30x30 (Lennard-Jones units) and spans from -15 to 15 in 
# each direction 
box periodic { lx = 30.0;  ly = 30.0;  lz = 30.0 }

# We read in particle positions from file hourglass.dat (generated by tools in utils directory)
input hourglass.dat

# We set the neighbour list with cutoff distance 1.5 and padding distance of 0.5
nlist { rcut = 2.4; pad = 0.5 }

# In following we define different data outputs

# Output particle velocities. Base name of the file is hourglass_test
# File extension will we '.vel'. Output will be generated every 10000 time steps
# staring from the step 0. Each snapshots will be stored in a separate file (keyword 'multi')
# with name hourglass_test_[time_step].vel (e.g., hourglass_test_0000010000.vel)
# and each file with contain a header with the description of its content
dump hourglass_test { type=velocity; start=0; freq=10000; multi; header }

# Same as above, but the format will be XYZ and file extension '.xyz'
dump hourglass_test { type=xyz; start=0; freq=10000; multi; header }

# In order to generate a trajectory, we output coordinates every 1000 time steps
# In this case all snapshots will be stored in one file 'hourglass_test.dcd'
dump hourglass_test { type=dcd; start=0; freq=1000  }

# It is also useful to have director field printed out (SimRePlay format)
dump hourglass_test_dir { type=xyzv; start=0; scale=0.2; freq=1000; header }

# As is the velocity field (also SimRePlay format)
dump hourglass_test_vel { type=xyzv; start=0; freq=1000; scale=0.1; velocity; header }


# Finally, every 10000 steps we generate a separate file that contains 
# particle coordinates, velocities and directors
dump hourglass_test { type=full; start=0; freq=10000; multi; coordinate; velocity; director; header  }


# We constrain all particles to move only on the surface of a hourglass if radius R = 10 with amplitude A = 2.0
# It is assumed that we have only one waist (node)
constraint hourglass { R = 10.0; A = 2.0  }


# All particles are interacting with the soft-core potential of strength 
# k = 10.0 (energy units)
pair_potential soft { k = 10.0 }


# Alignment will be done using polar aligner 
# Coupling constant J = 1.0 (energy units)
pair_align polar { J = 1.0 }

# We would also like to monitor measure a few quantities
# Here we define a log that keeps track of step, velocity, soft core potenetial energy, and alignment 
# These quantities will be logged once every 1000 steps
# Note that step is always logged automatically
log hourglass_test.log { freq = 1000; velocity; soft_energy; polar_align; vec_velocity }

# In order to relax the system and remove large overlaps 
# we first run system using NVE integrator with maximum 
# displacement limit=0.001. Time step is dt = 0.001
integrator nve { dt=0.001; limit=0.0001  }

# Run for 10,000 steps
run 10000

disable nve { group=all }

# Now we are at the point to execute actual simulations. 
# We switch the integrator to brownian.
# Integrate equations of motion using Brownian dynamics.
# seed is the initial seed for the random number generator
# dt is the integrator time step (in Lennard-Jones units) 
# nu sets the width of the distribution for random changes of velocity
# mu is particle mobility
# v0 is the intensity of the self-propelling velocity
integrator brownian { dt=0.001; seed = 0;  nu = 0.002; mu = 1.0;  v0 = 1.0 }

# Finally, we run simulation for 100,000 time steps
run 100000


