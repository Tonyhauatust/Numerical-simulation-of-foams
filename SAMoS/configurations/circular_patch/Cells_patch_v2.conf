# * ***************************************************************************
# *
# *  Copyright (C) 2013-2016 University of Dundee
# *  All rights reserved. 
# *
# *  This file is part of SAMoS (Soft Active Matter on Surfaces) program.
# *
# *  SAMoS is free software; you can redistribute it and/or modify
# *  it under the terms of the GNU General Public License as published by
# *  the Free Software Foundation; either version 2 of the License, or
# *  (at your option) any later version.
# *
# *  SAMoS is distributed in the hope that it will be useful,
# *  but WITHOUT ANY WARRANTY; without even the implied warranty of
# *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# *  GNU General Public License for more details.
# *
# *  You should have received a copy of the GNU General Public License
# *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# *
# * ****************************************************************************

#
#  Simulation of a tissue patch using the Active Vertex Model
#  

# All runtime messages will be sent to file messages.msg
messages messages.msg

# Every simulation requires a box
# "fixed" means that particles cannot cross the boundary. This is required in the AVM.
# In order to avoid problems, we make the box very large in x and y direction. z direction 
# is not important. 
box fixed { lx = 1000.0;  ly = 1000.0;  lz = 10.0 }

# We read in cell positions from file patch.dat (generated by tools in utils directory)
input patch.dat

# We set the neighbour list with cutoff distance 2.4 and padding distance of 0.5
nlist { rcut = 3.0; pad = 0.5; build_faces; max_perimeter = 30.0 }


# In following we define different data outputs

# Output particle velocities. Base name of the file is plane_test
# File extension will we '.vel'. Output will be generated every 10000 time steps
# staring from the step 0. Each snapshots will be stored in a separate file (keyword 'multi')
# with name plane_test_[time_step].vel (e.g., plane_test_0000010000.vel)
# and each file with contain a header with the description of its content
#dump plane_test { type=velocity; start=0; freq=10000; multi; header }

# Same as above, but the format will be XYZ and file extension '.xyz'
#dump plane_test { type=xyz; start=0; freq=10000; multi; header }

# In order to generate a trajectory, we output coordinates every 1000 time steps
# In this case all snapshots will be stored in one file 'plane_test.dcd'
#dump plane_test { type=dcd; start=0; freq=1000  }

# We also want to generate a director field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'plane_test_dir.xyzv'
#dump plane_test_dir { type=xyzv; start=0; freq=1000; scale = 0.25; header  }

# In addition we want to generate a velocity field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'plane_test_vel.xyzv'
#dump plane_test_vel { type=xyzv; start=0; freq=1000; scale = 0.1; velocity; header  }


# Finally, every 10000 steps we generate a separate file that contains 
# particle coordinates, velocities anf the director field (and the header)
#dump plane { type=mesh; start=0; freq=100; multi; header }


# We constrain all particles to move only on the xy plane with lx=100, ly = 100 (actually those are read from the box)
constraint plane { unlimited  }

# All particles are interacting with the soft-core potential of strength 
# k = 1.0 (energy units)
#pair_potential soft { k = 1.0 }
pair_potential vp { K = 5.0; gamma = 0.0; lambda = 0.0; }
#pair_potential soft { k = 5.0; use_particle_radii }
#pair_potential line_tension { lambda = 0.005; }

#log cell.log { freq = 10; size; area; avg_perim; vp_energy; soft_energy; line_tension_energy }
log cell.log { freq = 10; size; area; avg_perim; vp_energy }


# We would also like to monitor measure a few quantities
# Here we define a log that keeps track of step, velocity, soft core potenetial energy, and alignment 
# These quantities will be logged once every 1000 steps
# Note that step is always logged automatically


# In order to relax the system and remove large overlaps 
# we first run system using NVE integrator with maximum 
# displacement limit=0.001. Time step is dt = 0.001
# We switch the integrator to brownian.
# Integrate equations of motion using Brownian dynamics.
# seed is the initial seed for the random number generator
# dt is the integrator time step (in Lennard-Jones units) 
# nu sets the width of the distribution for random changes of velocity
# mu is particle mobility
# v0 is the intensity of the self-propelling velocity
integrator brownian { dt=0.001; seed = 1;  nu = 0.0; mu = 1.0;  v0 = 0.0 }

run 10000

dump cell { type=vtp; start=0; freq=500; multi }
dump cell_dual { type=vtp; start=0; freq=500; multi; dual }
dump cell { type=full; start=0; freq=2500; multi; coordinate; velocity; a0; cell_area; cell_perim; cont_num; boundary; header }

population cell { group = all; division_rate = 0.01; death_rate = 0.0; freq = 1500; max_area = 7.0; growth_rate = 0.005  }

# Apply random population control only to group "g"
# Particle division rate is set to 1000
# Particle removal rate is set to 1000
# Division and removal are attempted only every 1000 steps
#population density { group = g; division_rate = 0.1; death_rate = 0.0; freq = 100; change_prob_1 = 0.0; split_distance = 2.0; change_prob_2 = 1.0; old_group = g; new_group = p; old_type = 2; new_type = 1  }
#population density { group = all; division_rate = 0.1; death_rate = 0.001; freq = 1000  }
#population density { group = p; division_rate = 0.0; death_rate = 1e-4; freq = 100; change_prob_1 = 0.0; change_prob_2 = 0.0  }

#ntypes 6

# Finally, we run simulation for 100,000 time steps
run 1000000



