# * ***************************************************************************
# *
# *  Copyright (C) 2013-2016 University of Dundee
# *  All rights reserved. 
# *
# *  This file is part of SAMoS (Soft Active Matter on Surfaces) program.
# *
# *  SAMoS is free software; you can redistribute it and/or modify
# *  it under the terms of the GNU General Public License as published by
# *  the Free Software Foundation; either version 2 of the License, or
# *  (at your option) any later version.
# *
# *  SAMoS is distributed in the hope that it will be useful,
# *  but WITHOUT ANY WARRANTY; without even the implied warranty of
# *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# *  GNU General Public License for more details.
# *
# *  You should have received a copy of the GNU General Public License
# *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
# *
# * ****************************************************************************

#
#  Simulation of N=786 active particles interacting with the 
#  soft-core potential confined on the surface of a Gaussian bump
#  


# All runtime messages will be sent to file messages.msg
messages messages.msg

# Every simulation requires a box
# "periodic" means that periodic boundary are applied.
# box is cubic with size 50x50x50 (units of particle radius r = 1) and spans from -50 to 50 in 
box periodic { lx = 50.0;  ly = 50.0;  lz = 50.0 }

# We read in particle positions from file bump.dat (generated by tools in utils directory)
input bump.dat

# We set the neighbour list with cutoff distance 2.4 and padding distance of 0.5
nlist { rcut = 2.5; pad = 0.5 }


# In following we define different data outputs

# Output particle velocities. Base name of the file is bump_test
# File extension will we '.vel'. Output will be generated every 10000 time steps
# staring from the step 0. Each snapshots will be stored in a separate file (keyword 'multi')
# with name bump_test_[time_step].vel (e.g., bump_test_0000010000.vel)
# and each file with contain a header with the description of its content
dump bump_test { type=velocity; start=0; freq=10000; multi; header }

# Same as above, but the format will be XYZ and file extension '.xyz'
dump bump_test { type=xyz; start=0; freq=10000; multi; header }

# We also want to generate a director field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'bump_test_dir.xyzv'
dump bump_test_dir { type=xyzv; start=0; freq=1000; scale = 0.25; header  }

# In addition we want to generate a velocity field file that can be directly visualized by SimRePlay
# In this case all snapshots will be stored in one file 'bump_test_vel.xyzv'
dump bump_test_vel { type=xyzv; start=0; freq=1000; scale = 0.1; velocity; header  }


# Finally, every 10000 steps we generate a separate file that contains 
# particle coordinates, velocities anf the director field (and the header)
dump bump_test { type=full; start=0; freq=1000; multi; coordinate; velocity; director; header  }

# We also produce VTP files for simple visualisation with Paraview
dump bump_test { type=vtp; start=0; freq=1000; multi }

# We constrain all particles to move only on the xy bump with lx=100, ly = 100 (actually those are read from the box)
constraint gaussian_bump { A = 3.0; a = 8.0; b = 8.0 }


# All particles are interacting with the soft-core potential of strength 
# k = 1.0 (energy units)
pair_potential soft { k = 0.0 }

# Alignment will be done using polar aligner 
# Coupling constant J = 0.25 (energy units)
pair_align polar { J = 1.0 }

# we now add self-propulsion in the direction of the director
# alpha = 1.0 is the strength of propulsion
external self_propulsion { alpha = 1.0 }

# Set time step is dt = 0.01
timestep 0.01

# In order to relax the system and remove large overlaps 
# we first run system using NVE integrator with maximum 
# displacement limit=0.001. Time step is dt = 0.001
integrator nve { dt=0.001; limit=0.0001 }


# Run for 10,000 steps
run 10000

disable nve { group=all }


# Now we are at the point to execute actual simulations.
# We switch to the Brownian integrator for particle position
# Integrate equations of motion using Brownian dynamics.
# seed is the initial seed for the random number generator
# mu is particle mobility
integrator brownian_pos { seed = 0; mu = 1.0 }

# in order to integrate equations of motion for the director, we'll also use Brownian
# dynamics integrator. We'll set seed for the random number generator to 0 and
# add a bit of rotational noise (nu = 0.01)
integrator brownian_align { seed = 0; nu = 0.01;  }


# Finally, we run simulation for 100,000 time steps
run 1000000



